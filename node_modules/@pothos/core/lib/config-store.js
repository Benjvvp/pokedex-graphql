/* eslint-disable @typescript-eslint/no-redundant-type-constituents */ /* eslint-disable node/no-callback-literal */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return ConfigStore;
    }
});
const _graphql = require("graphql");
const _errors = require("./errors");
const _base = /*#__PURE__*/ _interop_require_default(require("./refs/base"));
const _builtinscalar = /*#__PURE__*/ _interop_require_default(require("./refs/builtin-scalar"));
const _input = /*#__PURE__*/ _interop_require_default(require("./refs/input"));
const _inputlist = /*#__PURE__*/ _interop_require_default(require("./refs/input-list"));
const _list = /*#__PURE__*/ _interop_require_default(require("./refs/list"));
const _output = /*#__PURE__*/ _interop_require_default(require("./refs/output"));
const _utils = require("./utils");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class ConfigStore {
    hasConfig(typeParam) {
        if (typeof typeParam === 'string') {
            return this.typeConfigs.has(typeParam);
        }
        return this.refsToName.has(typeParam);
    }
    addUnionTypes(typeName, unionTypes) {
        this.onPrepare(()=>{
            const typeConfig = this.getTypeConfig(typeName);
            if (typeConfig.graphqlKind !== 'Union') {
                throw new _errors.PothosSchemaError(`Can not add types to ${typeName} because it is a ${typeConfig.kind}`);
            }
            typeConfig.types = [
                ...typeConfig.types,
                ...typeof unionTypes === 'function' ? unionTypes() : unionTypes
            ];
        });
    }
    addInterfaces(typeName, interfaces) {
        this.onPrepare(()=>{
            const typeConfig = this.getTypeConfig(typeName);
            if (typeConfig.graphqlKind !== 'Object' && typeConfig.graphqlKind !== 'Interface' || typeConfig.kind === 'Query' || typeConfig.kind === 'Mutation' || typeConfig.kind === 'Subscription') {
                throw new _errors.PothosSchemaError(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
            }
            typeConfig.interfaces = [
                ...typeConfig.interfaces,
                ...typeof interfaces === 'function' ? interfaces() : interfaces
            ];
        });
    }
    addFieldRef(ref, // We need to be able to resolve the types kind before configuring the field
    typeParam, args, getConfig) {
        if (this.fieldRefs.has(ref)) {
            throw new _errors.PothosSchemaError(`FieldRef ${String(ref)} has already been added to config store`);
        }
        const typeRefOrName = (0, _utils.unwrapListParam)(typeParam);
        const argRefs = Object.keys(args).map((argName)=>{
            const argRef = args[argName];
            argRef.fieldName = argName;
            argRef.argFor = ref;
            return argRef;
        });
        const checkArgs = ()=>{
            for (const arg of argRefs){
                if (this.pendingFields.has(arg)) {
                    const unresolvedArgType = this.pendingFields.get(arg);
                    this.pendingFields.set(ref, unresolvedArgType);
                    this.onTypeConfig(unresolvedArgType, checkArgs);
                    return;
                }
            }
            this.pendingFields.delete(ref);
            this.fieldRefs.set(ref, getConfig);
        };
        if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof _base.default || this.scalarsToRefs.has(typeRefOrName)) {
            checkArgs();
        } else {
            this.pendingFields.set(ref, typeRefOrName);
            this.onTypeConfig(typeRefOrName, ()=>{
                checkArgs();
            });
        }
    }
    createFieldConfig(ref, name, typeConfig, parentField, kind) {
        if (!this.fieldRefs.has(ref)) {
            if (this.pendingFields.has(ref)) {
                throw new _errors.PothosSchemaError(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))} used in field ${name} of ${typeConfig.name}`);
            }
            throw new _errors.PothosSchemaError(`Missing definition for ${String(ref)}`);
        }
        const config = this.fieldRefs.get(ref)(name, parentField, typeConfig);
        if (kind && config.graphqlKind !== kind) {
            throw new _errors.PothosError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config.graphqlKind}`);
        }
        return config;
    }
    associateRefWithName(ref, name) {
        if (!this.typeConfigs.has(name)) {
            throw new _errors.PothosSchemaError(`${name} has not been implemented yet`);
        }
        this.refsToName.set(ref, name);
        if (this.pendingRefResolutions.has(ref)) {
            const cbs = this.pendingRefResolutions.get(ref);
            this.pendingRefResolutions.delete(ref);
            cbs.forEach((cb)=>void cb(this.typeConfigs.get(name)));
        }
    }
    addTypeConfig(config, ref) {
        const { name } = config;
        if (this.typeConfigs.has(name)) {
            throw new _errors.PothosSchemaError(`Duplicate typename: Another type with name ${name} already exists.`);
        }
        this.typeConfigs.set(config.name, config);
        if (ref) {
            this.associateRefWithName(ref, name);
        }
        if (this.pendingRefResolutions.has(name)) {
            const cbs = this.pendingRefResolutions.get(name);
            this.pendingRefResolutions.delete(name);
            cbs.forEach((cb)=>void cb(config));
        }
    }
    getTypeConfig(ref, kind) {
        let config;
        if (typeof ref === 'string') {
            if (!this.typeConfigs.has(ref)) {
                throw new _errors.PothosSchemaError(`Type ${String(ref)} has not been implemented`);
            }
            config = this.typeConfigs.get(ref);
        } else if (this.refsToName.has(ref)) {
            config = this.typeConfigs.get(this.refsToName.get(ref));
        } else if (ref instanceof _list.default || ref instanceof _inputlist.default) {
            throw new _errors.PothosSchemaError(`Expected a base type but got a ${ref.kind} of ${String(ref.listType)}`);
        } else {
            throw new _errors.PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
        }
        if (kind && config.graphqlKind !== kind) {
            throw new _errors.PothosSchemaError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
        }
        return config;
    }
    getInputTypeRef(ref) {
        if (ref instanceof _base.default) {
            if (ref.kind !== 'InputObject' && ref.kind !== 'Enum' && ref.kind !== 'Scalar') {
                throw new _errors.PothosSchemaError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
            }
            return ref;
        }
        if (typeof ref === 'string') {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind !== 'InputObject' && config.graphqlKind !== 'Enum' && config.graphqlKind !== 'Scalar') {
                    throw new _errors.PothosSchemaError(`Expected ${config.name} to be an input type but got ${config.graphqlKind}`);
                }
                const newRef = new _input.default(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    getOutputTypeRef(ref) {
        if (ref instanceof _base.default) {
            if (ref.kind === 'InputObject' || ref.kind === 'InputList') {
                throw new _errors.PothosSchemaError(`Expected ${ref.name} to be an output type but got ${ref.kind}`);
            }
            if (ref.kind === 'List') {
                throw new _errors.PothosSchemaError(`Expected ${ref.name} to be a base type but got a ${ref.kind}`);
            }
            return ref;
        }
        if (typeof ref === 'string') {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind === 'InputObject') {
                    throw new _errors.PothosSchemaError(`Expected ${config.name} to be an output type but got ${config.graphqlKind}`);
                }
                const newRef = new _output.default(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    onTypeConfig(ref, cb) {
        if (!ref) {
            throw new _errors.PothosSchemaError(`${String(ref)} is not a valid type ref`);
        }
        if (this.refsToName.has(ref)) {
            cb(this.getTypeConfig(ref));
        } else if (typeof ref === 'string' && this.typeConfigs.has(ref)) {
            cb(this.typeConfigs.get(ref));
        } else if (!this.pending) {
            throw new _errors.PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
        } else if (this.pendingRefResolutions.has(ref)) {
            this.pendingRefResolutions.get(ref).push(cb);
        } else {
            this.pendingRefResolutions.set(ref, [
                cb
            ]);
        }
    }
    onFieldUse(ref, cb) {
        if (!this.fieldRefCallbacks.has(ref)) {
            this.fieldRefCallbacks.set(ref, []);
        }
        this.fieldRefCallbacks.get(ref).push(cb);
        if (this.fieldRefsToConfigs.has(ref)) {
            this.fieldRefsToConfigs.get(ref).forEach((config)=>void cb(config));
        }
    }
    getFields(name, kind) {
        const typeConfig = this.getTypeConfig(name);
        if (!this.fields.has(name)) {
            this.fields.set(name, new Map());
        }
        const fields = this.fields.get(name);
        if (kind && typeConfig.graphqlKind !== kind) {
            throw new _errors.PothosSchemaError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
        }
        return fields;
    }
    prepareForBuild() {
        this.pending = false;
        const { pendingActions } = this;
        this.pendingActions = [];
        pendingActions.forEach((fn)=>void fn());
        if (this.pendingRefResolutions.size > 0) {
            throw new _errors.PothosSchemaError(`Missing implementations for some references (${[
                ...this.pendingRefResolutions.keys()
            ].map((ref)=>this.describeRef(ref)).join(', ')}).`);
        }
    }
    onPrepare(cb) {
        if (this.pending) {
            this.pendingActions.push(cb);
        } else {
            cb();
        }
    }
    addFields(typeRef, fields) {
        this.onPrepare(()=>void this.onTypeConfig(typeRef, (config)=>{
                this.buildFields(typeRef, typeof fields === 'function' ? fields() : fields);
            }));
    }
    getImplementers(ref) {
        const typeConfig = this.getTypeConfig(ref, 'Interface');
        const implementers = [
            ...this.typeConfigs.values()
        ].filter((type)=>type.kind === 'Object' && type.interfaces.find((i)=>this.getTypeConfig(i).name === typeConfig.name));
        return implementers;
    }
    describeRef(ref) {
        var _find;
        if (typeof ref === 'string') {
            return ref;
        }
        if (ref.toString !== ({}).toString) {
            return String(ref);
        }
        const usedBy = (_find = [
            ...this.pendingFields.entries()
        ].find(([fieldRef, typeRef])=>typeRef === ref)) === null || _find === void 0 ? void 0 : _find[0];
        if (usedBy) {
            return `<unnamed ref or enum: used by ${usedBy}>`;
        }
        return `<unnamed ref or enum>`;
    }
    buildFields(typeRef, fields) {
        Object.keys(fields).forEach((fieldName)=>{
            const fieldRef = fields[fieldName];
            fieldRef.fieldName = fieldName;
            if (this.pendingFields.has(fieldRef)) {
                this.onTypeConfig(this.pendingFields.get(fieldRef), ()=>{
                    this.buildField(typeRef, fieldRef, fieldName);
                });
            } else {
                this.buildField(typeRef, fieldRef, fieldName);
            }
        });
    }
    buildField(typeRef, field, fieldName) {
        const typeConfig = this.getTypeConfig(typeRef);
        const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
        const existingFields = this.getFields(typeConfig.name);
        if (existingFields.has(fieldName)) {
            throw new _errors.PothosSchemaError(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
        }
        if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
            throw new _errors.PothosSchemaError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
        }
        existingFields.set(fieldName, fieldConfig);
        if (!this.fieldRefsToConfigs.has(field)) {
            this.fieldRefsToConfigs.set(field, []);
        }
        this.fieldRefsToConfigs.get(field).push(fieldConfig);
        if (this.fieldRefCallbacks.has(field)) {
            this.fieldRefCallbacks.get(field).forEach((cb)=>void cb(fieldConfig));
        }
    }
    constructor(){
        _define_property(this, "typeConfigs", new Map());
        _define_property(this, "fieldRefs", new WeakMap());
        _define_property(this, "fields", new Map());
        _define_property(this, "pendingActions", []);
        _define_property(this, "refsToName", new Map());
        _define_property(this, "scalarsToRefs", new Map());
        _define_property(this, "fieldRefsToConfigs", new Map());
        _define_property(this, "pendingFields", new Map());
        _define_property(this, "pendingRefResolutions", new Map());
        _define_property(this, "fieldRefCallbacks", new Map());
        _define_property(this, "pending", true);
        const scalars = [
            _graphql.GraphQLID,
            _graphql.GraphQLInt,
            _graphql.GraphQLFloat,
            _graphql.GraphQLString,
            _graphql.GraphQLBoolean
        ];
        scalars.forEach((scalar)=>{
            const ref = new _builtinscalar.default(scalar);
            this.scalarsToRefs.set(scalar.name, ref);
            this.refsToName.set(ref, scalar.name);
        });
    }
}

//# sourceMappingURL=config-store.js.map