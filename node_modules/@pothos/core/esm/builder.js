function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
import { GraphQLBoolean, GraphQLFloat, GraphQLID, GraphQLInt, GraphQLSchema, GraphQLString, lexicographicSortSchema } from 'graphql';
import BuildCache from './build-cache.js';
import ConfigStore from './config-store.js';
import { PothosError, PothosSchemaError } from './errors.js';
import InputFieldBuilder from './fieldUtils/input.js';
import InterfaceFieldBuilder from './fieldUtils/interface.js';
import MutationFieldBuilder from './fieldUtils/mutation.js';
import ObjectFieldBuilder from './fieldUtils/object.js';
import QueryFieldBuilder from './fieldUtils/query.js';
import SubscriptionFieldBuilder from './fieldUtils/subscription.js';
import BaseTypeRef from './refs/base.js';
import EnumRef from './refs/enum.js';
import InputObjectRef, { ImplementableInputObjectRef } from './refs/input-object.js';
import InterfaceRef, { ImplementableInterfaceRef } from './refs/interface.js';
import ObjectRef, { ImplementableObjectRef } from './refs/object.js';
import ScalarRef from './refs/scalar.js';
import UnionRef from './refs/union.js';
import { normalizeEnumValues, valuesFromEnum, verifyInterfaces, verifyRef } from './utils/index.js';
class SchemaBuilder {
    static registerPlugin(name, plugin) {
        if (!this.allowPluginReRegistration && this.plugins[name]) {
            throw new PothosError(`Received multiple implementations for plugin ${name}`);
        }
        this.plugins[name] = plugin;
    }
    objectType(param, options, fields) {
        verifyRef(param);
        verifyInterfaces(options.interfaces);
        var _options_name;
        const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
        if (name === "Query" || name === "Mutation" || name === "Subscription") {
            throw new PothosSchemaError(`Invalid object name ${name} use .create${name}Type() instead`);
        }
        const ref = param instanceof BaseTypeRef ? param : new ObjectRef(name);
        const config = {
            kind: "Object",
            graphqlKind: "Object",
            name,
            interfaces: [],
            description: options.description,
            extensions: options.extensions,
            isTypeOf: options.isTypeOf,
            pothosOptions: options
        };
        this.configStore.addTypeConfig(config, ref);
        if (options.interfaces) {
            this.configStore.addInterfaces(name, options.interfaces);
        }
        if (typeof param === "function") {
            this.configStore.associateRefWithName(param, name);
        }
        if (fields) {
            this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
        }
        if (options.fields) {
            this.configStore.addFields(ref, () => {
                const t = new ObjectFieldBuilder(name, this);
                return options.fields(t);
            });
        }
        return ref;
    }
    objectFields(ref, fields) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name }) => {
            this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
        });
    }
    objectField(ref, fieldName, field) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name }) => {
            this.configStore.addFields(ref, () => ({
                [fieldName]: field(new ObjectFieldBuilder(name, this))
            }));
        });
    }
    queryType(...args) {
        const [options = {}, fields] = args;
        const config = {
            kind: "Query",
            graphqlKind: "Object",
            name: "Query",
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        const ref = new ObjectRef("Query");
        this.configStore.addTypeConfig(config, ref);
        if (fields) {
            this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields("Query", () => options.fields(new QueryFieldBuilder(this)));
        }
        return ref;
    }
    queryFields(fields) {
        this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
    }
    queryField(name, field) {
        this.configStore.addFields("Query", () => ({
            [name]: field(new QueryFieldBuilder(this))
        }));
    }
    mutationType(...args) {
        const [options = {}, fields] = args;
        const config = {
            kind: "Mutation",
            graphqlKind: "Object",
            name: "Mutation",
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields("Mutation", () => options.fields(new MutationFieldBuilder(this)));
        }
    }
    mutationFields(fields) {
        this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
    }
    mutationField(name, field) {
        this.configStore.addFields("Mutation", () => ({
            [name]: field(new MutationFieldBuilder(this))
        }));
    }
    subscriptionType(...args) {
        const [options = {}, fields] = args;
        const config = {
            kind: "Subscription",
            graphqlKind: "Object",
            name: "Subscription",
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields("Subscription", () => options.fields(new SubscriptionFieldBuilder(this)));
        }
    }
    subscriptionFields(fields) {
        this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
    }
    subscriptionField(name, field) {
        this.configStore.addFields("Subscription", () => ({
            [name]: field(new SubscriptionFieldBuilder(this))
        }));
    }
    args(fields) {
        return fields(new InputFieldBuilder(this, "Arg", "[unknown]"));
    }
    interfaceType(param, options, fields) {
        verifyRef(param);
        verifyInterfaces(options.interfaces);
        var _options_name;
        const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
        const ref = param instanceof BaseTypeRef ? param : new InterfaceRef(name);
        const typename = ref.name;
        const config = {
            kind: "Interface",
            graphqlKind: "Interface",
            name: typename,
            interfaces: [],
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions,
            resolveType: options.resolveType
        };
        this.configStore.addTypeConfig(config, ref);
        if (options.interfaces) {
            this.configStore.addInterfaces(typename, options.interfaces);
        }
        if (typeof param === "function") {
            this.configStore.associateRefWithName(param, name);
        }
        if (fields) {
            this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(typename, this)));
        }
        if (options.fields) {
            this.configStore.addFields(ref, () => options.fields(new InterfaceFieldBuilder(typename, this)));
        }
        return ref;
    }
    interfaceFields(ref, fields) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name }) => {
            this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(name, this)));
        });
    }
    interfaceField(ref, fieldName, field) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name }) => {
            this.configStore.addFields(ref, () => ({
                [fieldName]: field(new InterfaceFieldBuilder(name, this))
            }));
        });
    }
    unionType(name, options) {
        const ref = new UnionRef(name);
        if (Array.isArray(options.types)) {
            options.types.forEach((type) => {
                verifyRef(type);
            });
        }
        const config = {
            kind: "Union",
            graphqlKind: "Union",
            name,
            types: [],
            description: options.description,
            resolveType: options.resolveType,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        this.configStore.addUnionTypes(name, options.types);
        return ref;
    }
    enumType(param, options) {
        verifyRef(param);
        const name = typeof param === "string" ? param : options.name;
        const ref = new EnumRef(name);
        const values = typeof param === "object" ? valuesFromEnum(// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        param, options === null || options === void 0 ? void 0 : options.values) : normalizeEnumValues(options.values);
        const config = {
            kind: "Enum",
            graphqlKind: "Enum",
            name,
            values,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        if (typeof param !== "string") {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            this.configStore.associateRefWithName(param, name);
        }
        return ref;
    }
    scalarType(name, options) {
        const ref = new ScalarRef(name);
        const config = {
            kind: "Scalar",
            graphqlKind: "Scalar",
            name,
            description: options.description,
            parseLiteral: options.parseLiteral,
            parseValue: options.parseValue,
            serialize: options.serialize,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        return ref;
    }
    addScalarType(name, scalar, ...args) {
        const [options = {}] = args;
        const config = scalar.toConfig();
        return this.scalarType(name, {
            ...config,
            ...options,
            extensions: {
                ...config.extensions,
                ...options.extensions
            }
        });
    }
    inputType(param, options) {
        verifyRef(param);
        const name = typeof param === "string" ? param : param.name;
        const ref = typeof param === "string" ? new InputObjectRef(name) : param;
        const config = {
            kind: "InputObject",
            graphqlKind: "InputObject",
            name,
            isOneOf: options.isOneOf,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        this.configStore.addFields(ref, () => options.fields(new InputFieldBuilder(this, "InputObject", name)));
        return ref;
    }
    inputRef(name) {
        return new ImplementableInputObjectRef(this, name);
    }
    objectRef(name) {
        return new ImplementableObjectRef(this, name);
    }
    interfaceRef(name) {
        return new ImplementableInterfaceRef(this, name);
    }
    toSchema(...args) {
        const [options = {}] = args;
        const { directives, extensions } = options;
        const scalars = [
            GraphQLID,
            GraphQLInt,
            GraphQLFloat,
            GraphQLString,
            GraphQLBoolean
        ];
        scalars.forEach((scalar) => {
            if (!this.configStore.hasConfig(scalar.name)) {
                this.addScalarType(scalar.name, scalar);
            }
        });
        const buildCache = new BuildCache(this, options);
        buildCache.plugin.beforeBuild();
        buildCache.buildAll();
        const builtTypes = [
            ...buildCache.types.values()
        ];
        const schema = new GraphQLSchema({
            query: buildCache.types.get("Query"),
            mutation: buildCache.types.get("Mutation"),
            subscription: buildCache.types.get("Subscription"),
            extensions: extensions !== null && extensions !== void 0 ? extensions : {},
            directives: directives,
            types: builtTypes
        });
        const processedSchema = buildCache.plugin.afterBuild(schema);
        return options.sortSchema === false ? processedSchema : lexicographicSortSchema(processedSchema);
    }
    constructor(options) {
        _define_property(this, "configStore", void 0);
        _define_property(this, "options", void 0);
        _define_property(this, "defaultFieldNullability", void 0);
        _define_property(this, "defaultInputFieldRequiredness", void 0);
        this.options = options;
        this.configStore = new ConfigStore();
        var _options_defaultFieldNullability;
        this.defaultFieldNullability = (_options_defaultFieldNullability = options.defaultFieldNullability) !== null && _options_defaultFieldNullability !== void 0 ? _options_defaultFieldNullability : false;
        var _options_defaultInputFieldRequiredness;
        this.defaultInputFieldRequiredness = (_options_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _options_defaultInputFieldRequiredness !== void 0 ? _options_defaultInputFieldRequiredness : false;
    }
}
_define_property(SchemaBuilder, "plugins", {});
_define_property(SchemaBuilder, "allowPluginReRegistration", false);
export { SchemaBuilder as default };
//# sourceMappingURL=builder.js.map
