/* eslint-disable @typescript-eslint/no-redundant-type-constituents */ /* eslint-disable node/no-callback-literal */ function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    }
    else {
        obj[key] = value;
    }
    return obj;
}
import { GraphQLBoolean, GraphQLFloat, GraphQLID, GraphQLInt, GraphQLString } from 'graphql';
import { PothosError, PothosSchemaError } from './errors.js';
import BaseTypeRef from './refs/base.js';
import BuiltinScalarRef from './refs/builtin-scalar.js';
import InputTypeRef from './refs/input.js';
import InputListRef from './refs/input-list.js';
import ListRef from './refs/list.js';
import OutputTypeRef from './refs/output.js';
import { unwrapListParam } from './utils/index.js';
class ConfigStore {
    hasConfig(typeParam) {
        if (typeof typeParam === "string") {
            return this.typeConfigs.has(typeParam);
        }
        return this.refsToName.has(typeParam);
    }
    addUnionTypes(typeName, unionTypes) {
        this.onPrepare(() => {
            const typeConfig = this.getTypeConfig(typeName);
            if (typeConfig.graphqlKind !== "Union") {
                throw new PothosSchemaError(`Can not add types to ${typeName} because it is a ${typeConfig.kind}`);
            }
            typeConfig.types = [
                ...typeConfig.types,
                ...typeof unionTypes === "function" ? unionTypes() : unionTypes
            ];
        });
    }
    addInterfaces(typeName, interfaces) {
        this.onPrepare(() => {
            const typeConfig = this.getTypeConfig(typeName);
            if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface" || typeConfig.kind === "Query" || typeConfig.kind === "Mutation" || typeConfig.kind === "Subscription") {
                throw new PothosSchemaError(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
            }
            typeConfig.interfaces = [
                ...typeConfig.interfaces,
                ...typeof interfaces === "function" ? interfaces() : interfaces
            ];
        });
    }
    addFieldRef(ref, // We need to be able to resolve the types kind before configuring the field
    typeParam, args, getConfig) {
        if (this.fieldRefs.has(ref)) {
            throw new PothosSchemaError(`FieldRef ${String(ref)} has already been added to config store`);
        }
        const typeRefOrName = unwrapListParam(typeParam);
        const argRefs = Object.keys(args).map((argName) => {
            const argRef = args[argName];
            argRef.fieldName = argName;
            argRef.argFor = ref;
            return argRef;
        });
        const checkArgs = () => {
            for (const arg of argRefs) {
                if (this.pendingFields.has(arg)) {
                    const unresolvedArgType = this.pendingFields.get(arg);
                    this.pendingFields.set(ref, unresolvedArgType);
                    this.onTypeConfig(unresolvedArgType, checkArgs);
                    return;
                }
            }
            this.pendingFields.delete(ref);
            this.fieldRefs.set(ref, getConfig);
        };
        if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof BaseTypeRef || this.scalarsToRefs.has(typeRefOrName)) {
            checkArgs();
        }
        else {
            this.pendingFields.set(ref, typeRefOrName);
            this.onTypeConfig(typeRefOrName, () => {
                checkArgs();
            });
        }
    }
    createFieldConfig(ref, name, typeConfig, parentField, kind) {
        if (!this.fieldRefs.has(ref)) {
            if (this.pendingFields.has(ref)) {
                throw new PothosSchemaError(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))} used in field ${name} of ${typeConfig.name}`);
            }
            throw new PothosSchemaError(`Missing definition for ${String(ref)}`);
        }
        const config = this.fieldRefs.get(ref)(name, parentField, typeConfig);
        if (kind && config.graphqlKind !== kind) {
            throw new PothosError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config.graphqlKind}`);
        }
        return config;
    }
    associateRefWithName(ref, name) {
        if (!this.typeConfigs.has(name)) {
            throw new PothosSchemaError(`${name} has not been implemented yet`);
        }
        this.refsToName.set(ref, name);
        if (this.pendingRefResolutions.has(ref)) {
            const cbs = this.pendingRefResolutions.get(ref);
            this.pendingRefResolutions.delete(ref);
            cbs.forEach((cb) => void cb(this.typeConfigs.get(name)));
        }
    }
    addTypeConfig(config, ref) {
        const { name } = config;
        if (this.typeConfigs.has(name)) {
            throw new PothosSchemaError(`Duplicate typename: Another type with name ${name} already exists.`);
        }
        this.typeConfigs.set(config.name, config);
        if (ref) {
            this.associateRefWithName(ref, name);
        }
        if (this.pendingRefResolutions.has(name)) {
            const cbs = this.pendingRefResolutions.get(name);
            this.pendingRefResolutions.delete(name);
            cbs.forEach((cb) => void cb(config));
        }
    }
    getTypeConfig(ref, kind) {
        let config;
        if (typeof ref === "string") {
            if (!this.typeConfigs.has(ref)) {
                throw new PothosSchemaError(`Type ${String(ref)} has not been implemented`);
            }
            config = this.typeConfigs.get(ref);
        }
        else if (this.refsToName.has(ref)) {
            config = this.typeConfigs.get(this.refsToName.get(ref));
        }
        else if (ref instanceof ListRef || ref instanceof InputListRef) {
            throw new PothosSchemaError(`Expected a base type but got a ${ref.kind} of ${String(ref.listType)}`);
        }
        else {
            throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
        }
        if (kind && config.graphqlKind !== kind) {
            throw new PothosSchemaError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
        }
        return config;
    }
    getInputTypeRef(ref) {
        if (ref instanceof BaseTypeRef) {
            if (ref.kind !== "InputObject" && ref.kind !== "Enum" && ref.kind !== "Scalar") {
                throw new PothosSchemaError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
            }
            return ref;
        }
        if (typeof ref === "string") {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind !== "InputObject" && config.graphqlKind !== "Enum" && config.graphqlKind !== "Scalar") {
                    throw new PothosSchemaError(`Expected ${config.name} to be an input type but got ${config.graphqlKind}`);
                }
                const newRef = new InputTypeRef(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    getOutputTypeRef(ref) {
        if (ref instanceof BaseTypeRef) {
            if (ref.kind === "InputObject" || ref.kind === "InputList") {
                throw new PothosSchemaError(`Expected ${ref.name} to be an output type but got ${ref.kind}`);
            }
            if (ref.kind === "List") {
                throw new PothosSchemaError(`Expected ${ref.name} to be a base type but got a ${ref.kind}`);
            }
            return ref;
        }
        if (typeof ref === "string") {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind === "InputObject") {
                    throw new PothosSchemaError(`Expected ${config.name} to be an output type but got ${config.graphqlKind}`);
                }
                const newRef = new OutputTypeRef(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    onTypeConfig(ref, cb) {
        if (!ref) {
            throw new PothosSchemaError(`${String(ref)} is not a valid type ref`);
        }
        if (this.refsToName.has(ref)) {
            cb(this.getTypeConfig(ref));
        }
        else if (typeof ref === "string" && this.typeConfigs.has(ref)) {
            cb(this.typeConfigs.get(ref));
        }
        else if (!this.pending) {
            throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
        }
        else if (this.pendingRefResolutions.has(ref)) {
            this.pendingRefResolutions.get(ref).push(cb);
        }
        else {
            this.pendingRefResolutions.set(ref, [
                cb
            ]);
        }
    }
    onFieldUse(ref, cb) {
        if (!this.fieldRefCallbacks.has(ref)) {
            this.fieldRefCallbacks.set(ref, []);
        }
        this.fieldRefCallbacks.get(ref).push(cb);
        if (this.fieldRefsToConfigs.has(ref)) {
            this.fieldRefsToConfigs.get(ref).forEach((config) => void cb(config));
        }
    }
    getFields(name, kind) {
        const typeConfig = this.getTypeConfig(name);
        if (!this.fields.has(name)) {
            this.fields.set(name, new Map());
        }
        const fields = this.fields.get(name);
        if (kind && typeConfig.graphqlKind !== kind) {
            throw new PothosSchemaError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
        }
        return fields;
    }
    prepareForBuild() {
        this.pending = false;
        const { pendingActions } = this;
        this.pendingActions = [];
        pendingActions.forEach((fn) => void fn());
        if (this.pendingRefResolutions.size > 0) {
            throw new PothosSchemaError(`Missing implementations for some references (${[
                ...this.pendingRefResolutions.keys()
            ].map((ref) => this.describeRef(ref)).join(", ")}).`);
        }
    }
    onPrepare(cb) {
        if (this.pending) {
            this.pendingActions.push(cb);
        }
        else {
            cb();
        }
    }
    addFields(typeRef, fields) {
        this.onPrepare(() => void this.onTypeConfig(typeRef, (config) => {
            this.buildFields(typeRef, typeof fields === "function" ? fields() : fields);
        }));
    }
    getImplementers(ref) {
        const typeConfig = this.getTypeConfig(ref, "Interface");
        const implementers = [
            ...this.typeConfigs.values()
        ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.getTypeConfig(i).name === typeConfig.name));
        return implementers;
    }
    describeRef(ref) {
        var _find;
        if (typeof ref === "string") {
            return ref;
        }
        if (ref.toString !== ({}).toString) {
            return String(ref);
        }
        const usedBy = (_find = [
            ...this.pendingFields.entries()
        ].find(([fieldRef, typeRef]) => typeRef === ref)) === null || _find === void 0 ? void 0 : _find[0];
        if (usedBy) {
            return `<unnamed ref or enum: used by ${usedBy}>`;
        }
        return `<unnamed ref or enum>`;
    }
    buildFields(typeRef, fields) {
        Object.keys(fields).forEach((fieldName) => {
            const fieldRef = fields[fieldName];
            fieldRef.fieldName = fieldName;
            if (this.pendingFields.has(fieldRef)) {
                this.onTypeConfig(this.pendingFields.get(fieldRef), () => {
                    this.buildField(typeRef, fieldRef, fieldName);
                });
            }
            else {
                this.buildField(typeRef, fieldRef, fieldName);
            }
        });
    }
    buildField(typeRef, field, fieldName) {
        const typeConfig = this.getTypeConfig(typeRef);
        const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
        const existingFields = this.getFields(typeConfig.name);
        if (existingFields.has(fieldName)) {
            throw new PothosSchemaError(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
        }
        if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
            throw new PothosSchemaError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
        }
        existingFields.set(fieldName, fieldConfig);
        if (!this.fieldRefsToConfigs.has(field)) {
            this.fieldRefsToConfigs.set(field, []);
        }
        this.fieldRefsToConfigs.get(field).push(fieldConfig);
        if (this.fieldRefCallbacks.has(field)) {
            this.fieldRefCallbacks.get(field).forEach((cb) => void cb(fieldConfig));
        }
    }
    constructor() {
        _define_property(this, "typeConfigs", new Map());
        _define_property(this, "fieldRefs", new WeakMap());
        _define_property(this, "fields", new Map());
        _define_property(this, "pendingActions", []);
        _define_property(this, "refsToName", new Map());
        _define_property(this, "scalarsToRefs", new Map());
        _define_property(this, "fieldRefsToConfigs", new Map());
        _define_property(this, "pendingFields", new Map());
        _define_property(this, "pendingRefResolutions", new Map());
        _define_property(this, "fieldRefCallbacks", new Map());
        _define_property(this, "pending", true);
        const scalars = [
            GraphQLID,
            GraphQLInt,
            GraphQLFloat,
            GraphQLString,
            GraphQLBoolean
        ];
        scalars.forEach((scalar) => {
            const ref = new BuiltinScalarRef(scalar);
            this.scalarsToRefs.set(scalar.name, ref);
            this.refsToName.set(ref, scalar.name);
        });
    }
}
export { ConfigStore as default };
//# sourceMappingURL=config-store.js.map
