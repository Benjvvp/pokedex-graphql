import { CompatibleTypes, ExposeNullability, FieldKind, FieldNullability, FieldOptionsFromKind, NormalizeArgs, SchemaTypes, TypeParam } from '../types/index.js';
import RootFieldBuilder from './root.js';
export default class FieldBuilder<Types extends SchemaTypes, ParentShape, Kind extends FieldKind = FieldKind> extends RootFieldBuilder<Types, ParentShape, Kind> {
    /**
     * Create a Boolean field from a boolean property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeBoolean<Name extends CompatibleTypes<Types, ParentShape, "Boolean", true>, ResolveReturnShape, Nullable extends FieldNullability<"Boolean"> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, "Boolean", Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, "Boolean", ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<FieldNullability<"Boolean"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("Boolean" extends infer T ? T extends "Boolean" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T> : never : never : never) | null | undefined : "Boolean" extends infer T_1 ? T_1 extends "Boolean" ? T_1 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_1] : T_1 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? ("Boolean" extends infer T_2 ? T_2 extends "Boolean" ? T_2 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_2] : T_2 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_2> : never : never : never) | null | undefined : "Boolean" extends infer T_3 ? T_3 extends "Boolean" ? T_3 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_3] : T_3 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_3> : never : never : never, Kind>;
    /**
     * Create a Float field from a numeric property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeFloat<Name extends CompatibleTypes<Types, ParentShape, "Float", true>, ResolveReturnShape, Nullable extends FieldNullability<"Float"> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, "Float", Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, "Float", ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<FieldNullability<"Float"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("Float" extends infer T ? T extends "Float" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T> : never : never : never) | null | undefined : "Float" extends infer T_1 ? T_1 extends "Float" ? T_1 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_1] : T_1 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? ("Float" extends infer T_2 ? T_2 extends "Float" ? T_2 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_2] : T_2 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_2> : never : never : never) | null | undefined : "Float" extends infer T_3 ? T_3 extends "Float" ? T_3 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_3] : T_3 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_3> : never : never : never, Kind>;
    /**
     * Create an ID field from a property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeID<Name extends CompatibleTypes<Types, ParentShape, "ID", true>, ResolveReturnShape, Nullable extends FieldNullability<"ID"> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, "ID", Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, "ID", ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<FieldNullability<"ID"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("ID" extends infer T ? T extends "ID" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T> : never : never : never) | null | undefined : "ID" extends infer T_1 ? T_1 extends "ID" ? T_1 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_1] : T_1 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? ("ID" extends infer T_2 ? T_2 extends "ID" ? T_2 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_2] : T_2 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_2> : never : never : never) | null | undefined : "ID" extends infer T_3 ? T_3 extends "ID" ? T_3 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_3] : T_3 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_3> : never : never : never, Kind>;
    /**
     * Create an Int field from a numeric property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeInt<Name extends CompatibleTypes<Types, ParentShape, "Int", true>, ResolveReturnShape, Nullable extends FieldNullability<"Int"> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, "Int", Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, "Int", ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<FieldNullability<"Int"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("Int" extends infer T ? T extends "Int" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T> : never : never : never) | null | undefined : "Int" extends infer T_1 ? T_1 extends "Int" ? T_1 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_1] : T_1 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? ("Int" extends infer T_2 ? T_2 extends "Int" ? T_2 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_2] : T_2 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_2> : never : never : never) | null | undefined : "Int" extends infer T_3 ? T_3 extends "Int" ? T_3 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_3] : T_3 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_3> : never : never : never, Kind>;
    /**
     * Create a String field from a string property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeString<Name extends CompatibleTypes<Types, ParentShape, "String", true>, ResolveReturnShape, Nullable extends FieldNullability<"String"> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, "String", Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, "String", ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<FieldNullability<"String"> extends Nullable ? Types["DefaultFieldNullability"] extends true ? ("String" extends infer T ? T extends "String" ? T extends keyof Types["outputShapes"] ? Types["outputShapes"][T] : T extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T> : never : never : never) | null | undefined : "String" extends infer T_1 ? T_1 extends "String" ? T_1 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_1] : T_1 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_1> : never : never : never : Nullable extends true ? ("String" extends infer T_2 ? T_2 extends "String" ? T_2 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_2] : T_2 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_2> : never : never : never) | null | undefined : "String" extends infer T_3 ? T_3 extends "String" ? T_3 extends keyof Types["outputShapes"] ? Types["outputShapes"][T_3] : T_3 extends import("../types/index.js").BaseEnum ? import("../types/index.js").ValuesFromEnum<T_3> : never : never : never, Kind>;
    /**
     * Create a Boolean list field from a boolean[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeBooleanList<Name extends CompatibleTypes<Types, ParentShape, [
        "Boolean"
    ], {
        list: true;
        items: true;
    }>, ResolveReturnShape, Nullable extends FieldNullability<[
        "Boolean"
    ]> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, [
            "Boolean"
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, [
            "Boolean"
        ], ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<import("../types/index.js").ShapeFromTypeParam<Types, [
        "Boolean"
    ], Nullable>, Kind>;
    /**
     * Create a Float list field from a number[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeFloatList<Name extends CompatibleTypes<Types, ParentShape, [
        "Float"
    ], {
        list: true;
        items: true;
    }>, ResolveReturnShape, Nullable extends FieldNullability<[
        "Float"
    ]> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, [
            "Float"
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, [
            "Float"
        ], ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<import("../types/index.js").ShapeFromTypeParam<Types, [
        "Float"
    ], Nullable>, Kind>;
    /**
     * Create an ID list field from an id[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeIDList<Name extends CompatibleTypes<Types, ParentShape, [
        "ID"
    ], {
        list: true;
        items: true;
    }>, ResolveReturnShape, Nullable extends FieldNullability<[
        "ID"
    ]> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, [
            "ID"
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, [
            "ID"
        ], ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<import("../types/index.js").ShapeFromTypeParam<Types, [
        "ID"
    ], Nullable>, Kind>;
    /**
     * Create a Int list field from a number[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeIntList<Name extends CompatibleTypes<Types, ParentShape, [
        "Int"
    ], {
        list: true;
        items: true;
    }>, ResolveReturnShape, Nullable extends FieldNullability<[
        "Int"
    ]> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, [
            "Int"
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, [
            "Int"
        ], ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<import("../types/index.js").ShapeFromTypeParam<Types, [
        "Int"
    ], Nullable>, Kind>;
    /**
     * Create a String list field from a string[] property on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    exposeStringList<Name extends CompatibleTypes<Types, ParentShape, [
        "String"
    ], {
        list: true;
        items: true;
    }>, ResolveReturnShape, Nullable extends FieldNullability<[
        "String"
    ]> = Types["DefaultFieldNullability"]>(name: Name, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, [
            "String"
        ], Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "type" | "nullable"> & ExposeNullability<Types, [
            "String"
        ], ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<import("../types/index.js").ShapeFromTypeParam<Types, [
        "String"
    ], Nullable>, Kind>;
    /**
     * Create a field that resolves to a property of the corresponding type on the parent object
     * @param {string} name - the name of the property on the source object (does not need to match the field name).
     * @param {object} [options={}] - Options for this field
     */
    expose<Type extends TypeParam<Types>, Nullable extends FieldNullability<Type>, ResolveReturnShape, Name extends CompatibleTypes<Types, ParentShape, Type, Type extends [
        unknown
    ] ? {
        list: true;
        items: true;
    } : true>>(name: Name extends keyof ParentShape ? Name : keyof ParentShape, ...args: NormalizeArgs<[
        options: Omit<FieldOptionsFromKind<Types, ParentShape, Type, Nullable, {}, Kind, ParentShape, ResolveReturnShape>, "resolve" | "nullable"> & ExposeNullability<Types, Type, ParentShape, Name, Nullable>
    ]>): import("../index.js").FieldRef<import("../types/index.js").ShapeFromTypeParam<Types, FieldOptionsFromKind<Types, ParentShape, Type, Nullable, {}, Kind, ParentShape, ResolveReturnShape>["type"], (Nullable & false & (Type extends [
        unknown
    ] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [
        T
    ] extends [
        NonNullable<T>
    ] ? (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? boolean | {
        items: boolean;
        list: boolean;
    } : true | {
        items: boolean;
        list: true;
    } : (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? {
        items: true;
        list: boolean;
    } : {
        items: true;
        list: true;
    } : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true)) | (Nullable & true & (Type extends [
        unknown
    ] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [
        T
    ] extends [
        NonNullable<T>
    ] ? (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? boolean | {
        items: boolean;
        list: boolean;
    } : true | {
        items: boolean;
        list: true;
    } : (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? {
        items: true;
        list: boolean;
    } : {
        items: true;
        list: true;
    } : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true)) | (Nullable & (Type extends [
        unknown
    ] ? boolean | {
        items: boolean;
        list: boolean;
    } : boolean) & (Type extends [
        unknown
    ] ? Awaited<ParentShape[Name]> extends readonly (infer T)[] | null | undefined ? [
        T
    ] extends [
        NonNullable<T>
    ] ? (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? boolean | {
        items: boolean;
        list: boolean;
    } : true | {
        items: boolean;
        list: true;
    } : (readonly T[] | null | undefined) & Awaited<ParentShape[Name]> extends readonly T[] & Awaited<ParentShape[Name]> ? {
        items: true;
        list: boolean;
    } : {
        items: true;
        list: true;
    } : never : Awaited<ParentShape[Name]> extends NonNullable<Awaited<ParentShape[Name]>> ? boolean : true))>, Kind>;
}
//# sourceMappingURL=builder.d.ts.map
