/* eslint-disable @typescript-eslint/ban-types */
import * as DefaultFetchAPI from '@whatwg-node/fetch';
import { completeAssign, handleErrorFromRequestHandler, isFetchEvent, isNodeRequest, isolateObject, isPromise, isRequestInit, isServerResponse, iterateAsyncVoid, normalizeNodeRequest, sendNodeResponse, } from './utils.js';
import { getRequestFromUWSRequest, isUWSResponse, sendResponseToUwsOpts, } from './uwebsockets.js';
async function handleWaitUntils(waitUntilPromises) {
    const waitUntils = await Promise.allSettled(waitUntilPromises);
    waitUntils.forEach(waitUntil => {
        if (waitUntil.status === 'rejected') {
            console.error(waitUntil.reason);
        }
    });
}
// Required for envs like nextjs edge runtime
function isRequestAccessible(serverContext) {
    try {
        return !!serverContext?.request;
    }
    catch {
        return false;
    }
}
function addWaitUntil(serverContext, waitUntilPromises) {
    serverContext['waitUntil'] = function (promise) {
        if (promise != null) {
            waitUntilPromises.push(promise);
        }
    };
}
const EMPTY_OBJECT = {};
function createServerAdapter(serverAdapterBaseObject, options) {
    const fetchAPI = {
        ...DefaultFetchAPI,
        ...options?.fetchAPI,
    };
    const givenHandleRequest = typeof serverAdapterBaseObject === 'function'
        ? serverAdapterBaseObject
        : serverAdapterBaseObject.handle;
    const onRequestHooks = [];
    const onResponseHooks = [];
    if (options?.plugins != null) {
        for (const plugin of options.plugins) {
            if (plugin.onRequest) {
                onRequestHooks.push(plugin.onRequest);
            }
            if (plugin.onResponse) {
                onResponseHooks.push(plugin.onResponse);
            }
        }
    }
    const handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0
        ? function handleRequest(request, serverContext) {
            let requestHandler = givenHandleRequest;
            let response;
            if (onRequestHooks.length === 0) {
                return handleEarlyResponse();
            }
            let url = new Proxy(EMPTY_OBJECT, {
                get(_target, prop, _receiver) {
                    url = new fetchAPI.URL(request.url, 'http://localhost');
                    return Reflect.get(url, prop, url);
                },
            });
            const onRequestHooksIteration$ = iterateAsyncVoid(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({
                request,
                serverContext,
                fetchAPI,
                url,
                requestHandler,
                setRequestHandler(newRequestHandler) {
                    requestHandler = newRequestHandler;
                },
                endResponse(newResponse) {
                    response = newResponse;
                    if (newResponse) {
                        stopEarly();
                    }
                },
            }));
            function handleResponse(response) {
                if (onRequestHooks.length === 0) {
                    return response;
                }
                const onResponseHookPayload = {
                    request,
                    response,
                    serverContext,
                };
                const onResponseHooksIteration$ = iterateAsyncVoid(onResponseHooks, onResponseHook => onResponseHook(onResponseHookPayload));
                if (isPromise(onResponseHooksIteration$)) {
                    return onResponseHooksIteration$.then(() => response);
                }
                return response;
            }
            function handleEarlyResponse() {
                if (!response) {
                    const response$ = requestHandler(request, serverContext);
                    if (isPromise(response$)) {
                        return response$.then(handleResponse);
                    }
                    return handleResponse(response$);
                }
                return handleResponse(response);
            }
            if (isPromise(onRequestHooksIteration$)) {
                return onRequestHooksIteration$.then(handleEarlyResponse);
            }
            return handleEarlyResponse();
        }
        : givenHandleRequest;
    function handleNodeRequest(nodeRequest, ...ctx) {
        const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};
        const request = normalizeNodeRequest(nodeRequest, fetchAPI.Request);
        return handleRequest(request, serverContext);
    }
    function requestListener(nodeRequest, serverResponse, ...ctx) {
        const waitUntilPromises = [];
        const defaultServerContext = {
            req: nodeRequest,
            res: serverResponse,
        };
        addWaitUntil(defaultServerContext, waitUntilPromises);
        let response$;
        try {
            response$ = handleNodeRequest(nodeRequest, defaultServerContext, ...ctx);
        }
        catch (err) {
            response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
        }
        if (isPromise(response$)) {
            return response$
                .catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response))
                .then(response => sendNodeResponse(response, serverResponse, nodeRequest))
                .catch(err => {
                console.error(`Unexpected error while handling request: ${err.message || err}`);
            });
        }
        try {
            return sendNodeResponse(response$, serverResponse, nodeRequest);
        }
        catch (err) {
            console.error(`Unexpected error while handling request: ${err.message || err}`);
        }
    }
    function handleUWS(res, req, ...ctx) {
        const waitUntilPromises = [];
        const defaultServerContext = {
            res,
            req,
        };
        addWaitUntil(defaultServerContext, waitUntilPromises);
        const serverContext = ctx.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;
        const request = getRequestFromUWSRequest({
            req,
            res,
            fetchAPI,
        });
        let resAborted = false;
        res.onAborted(() => {
            resAborted = true;
            request.signal.sendAbort();
        });
        let response$;
        try {
            response$ = handleRequest(request, serverContext);
        }
        catch (err) {
            response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
        }
        if (isPromise(response$)) {
            return response$
                .catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response))
                .then(response => {
                if (!resAborted) {
                    return sendResponseToUwsOpts(res, response);
                }
            })
                .catch(err => {
                console.error(`Unexpected error while handling request: ${err.message || err}`);
            });
        }
        try {
            return sendResponseToUwsOpts(res, response$);
        }
        catch (err) {
            console.error(`Unexpected error while handling request: ${err.message || err}`);
        }
    }
    function handleEvent(event, ...ctx) {
        if (!event.respondWith || !event.request) {
            throw new TypeError(`Expected FetchEvent, got ${event}`);
        }
        const serverContext = ctx.length > 0 ? Object.assign({}, event, ...ctx) : event;
        const response$ = handleRequest(event.request, serverContext);
        event.respondWith(response$);
    }
    function handleRequestWithWaitUntil(request, ...ctx) {
        const serverContext = ctx.length > 1 ? completeAssign(...ctx) : isolateObject(ctx[0]);
        if (serverContext.waitUntil == null) {
            const waitUntilPromises = [];
            addWaitUntil(serverContext, waitUntilPromises);
            const response$ = handleRequest(request, serverContext);
            if (waitUntilPromises.length > 0) {
                return handleWaitUntils(waitUntilPromises).then(() => response$);
            }
            return response$;
        }
        return handleRequest(request, serverContext);
    }
    const fetchFn = (input, ...maybeCtx) => {
        if (typeof input === 'string' || 'href' in input) {
            const [initOrCtx, ...restOfCtx] = maybeCtx;
            if (isRequestInit(initOrCtx)) {
                return handleRequestWithWaitUntil(new fetchAPI.Request(input, initOrCtx), ...restOfCtx);
            }
            return handleRequestWithWaitUntil(new fetchAPI.Request(input), ...maybeCtx);
        }
        return handleRequestWithWaitUntil(input, ...maybeCtx);
    };
    const genericRequestHandler = (input, ...maybeCtx) => {
        // If it is a Node request
        const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
        if (isNodeRequest(input)) {
            if (!isServerResponse(initOrCtxOrRes)) {
                throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
            }
            return requestListener(input, initOrCtxOrRes, ...restOfCtx);
        }
        if (isUWSResponse(input)) {
            return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
        }
        if (isServerResponse(initOrCtxOrRes)) {
            throw new TypeError('Got Node response without Node request');
        }
        // Is input a container object over Request?
        if (isRequestAccessible(input)) {
            // Is it FetchEvent?
            if (isFetchEvent(input)) {
                return handleEvent(input, ...maybeCtx);
            }
            // In this input is also the context
            return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
        }
        // Or is it Request itself?
        // Then ctx is present and it is the context
        return fetchFn(input, ...maybeCtx);
    };
    const adapterObj = {
        handleRequest,
        fetch: fetchFn,
        handleNodeRequest,
        requestListener,
        handleEvent,
        handleUWS,
        handle: genericRequestHandler,
    };
    const serverAdapter = new Proxy(genericRequestHandler, {
        // It should have all the attributes of the handler function and the server instance
        has: (_, prop) => {
            return (prop in adapterObj ||
                prop in genericRequestHandler ||
                (serverAdapterBaseObject && prop in serverAdapterBaseObject));
        },
        get: (_, prop) => {
            const adapterProp = adapterObj[prop];
            if (adapterProp) {
                if (adapterProp.bind) {
                    return adapterProp.bind(adapterObj);
                }
                return adapterProp;
            }
            const handleProp = genericRequestHandler[prop];
            if (handleProp) {
                if (handleProp.bind) {
                    return handleProp.bind(genericRequestHandler);
                }
                return handleProp;
            }
            if (serverAdapterBaseObject) {
                const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
                if (serverAdapterBaseObjectProp) {
                    if (serverAdapterBaseObjectProp.bind) {
                        return function (...args) {
                            const returnedVal = serverAdapterBaseObject[prop](...args);
                            if (returnedVal === serverAdapterBaseObject) {
                                return serverAdapter;
                            }
                            return returnedVal;
                        };
                    }
                    return serverAdapterBaseObjectProp;
                }
            }
        },
        apply(_, __, args) {
            return genericRequestHandler(...args);
        },
    });
    return serverAdapter;
}
export { createServerAdapter };
